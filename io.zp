(define (read? x) "read from a file if it is an input file, else return #f"
  (if (input-port? x)
    (read x)
    #f))

(define (write? x s) "write s to a file if it is an output file, else return #f"
  (if (output-port? x)
    (write x s)
    #f))

(define (newline . port) "print newline to port or stdout if none is given"
  (cond
    ((null? port) (write ""))
    ((eq? (list:length port) 1) (write "" (car port)))
    (else #f)))

(define (call-with-input-file s p) "open an input file s and apply a function to it, then close the file"
     (let ((inport (open-input-file s)))
          (if (eq? inport #f)
               #f
               (let ((res (p inport)))
                    (close-input-file inport)
                    res))))

(define (call-with-output-file s p) "open an output file s and apply a function to it, then close the file"
     (let ((outport (open-output-file s)))
          (if (eq? outport #f)
               #f
               (let ((res (p outport)))
                    (close-output-file outport)
                    res))))

(define (with-input-from-file s p) "open an input file s and run a function while it's open"
     (let ((inport (open-input-file s)))
          (if (eq? inport #f)
               #f
               (let ((prev-inport (current-input-port)))
                    (set-input-port inport)
                    (let ((res (p)))
                         (close-input-port inport)
                         (set-input-port prev-inport)
                         res)))))

(define (with-output-to-file s p) "open an output file s and run a function while it's open"
     (let ((outport (open-output-file s)))
          (if (eq? outport #f)
               #f
               (let ((prev-outport (current-output-port)))
                    (set-output-port outport)
                    (let ((res (p)))
                         (close-output-port outport)
                         (set-output-port prev-outport)
                         res)))))

(define (error reason . args) "prints an error to stderr"
  (let ((err (lambda (x) (display x :stderr))))
    (begin
      (err "Error: ")
      (err reason)
      (map (lambda (arg) (begin (err " ") (err arg))) args)
      (newline :stderr))))

(define (read-line port) "reads a line from the input port port"
  (let loop ((line "")
             (char (read-char port)))
      (if (or (boolean? char) (eq? char #\newline))
        line
        (loop (++ line char) (read-char port)))))

(define (file-exists? file) "test whether file exists"
  (not (boolean? (open-input-file file))))

(define (escape-sequence code . output) "sends escape sequence to output channel (default: stdout)"
  (display (++ (string #\x1b) "[" (->string code) "m") (get-from output 0 :stdout)))

(define (color col . output) "colors output to output channel (default: stdout)"
  (define colors #{:black 30
                   :red 31
                   :green 32
                   :yellow 33
                   :blue 34
                   :magenta 35
                   :cyan 36
                   :white 37
                   :reset 0
                   :none 0
                   :bold 1
                   italic 3
                   :underline 4
                   :blink-slow 5
                   :blink-rapid 6
                   :bg-black 40
                   :bg-red 41
                   :bg-green 42
                   :bg-yellow 43
                   :bg-blue 44
                   :bg-magenta 45
                   :bg-cyan 46
                   :bg-white 47})
  (let ((output (get-from output 0 :stdout))
        (col (if (number? col) col (colors col))))
      (escape-sequence col output)))
