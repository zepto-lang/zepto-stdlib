;; a lot of this is taken almost straight out of SICP

(define exact? integer?)
(define math:pi 245850922/78256779)
(define math:e 438351041/161260336)
(define (inexact? x) "is inexact number" (and (real? x) (not (integer? x))))
(define (math:even? n) "is even" (= (remainder n 2) 0))
(define (math:odd? n) "is odd" (not (= (remainder n 2) 0)))
(define (zero? n) "is zero" (= n 0))
(define (positive? n) "is positive" (> n 0))
(define (negative? n) "is negative" (< n 0))
(define complex? number?)
(define (/. . l) (foldl (lambda (x y) (/ (exact->inexact x) y)) (car l) (cdr l)))
(define (add1 x) (+ x 1))
(define (sub1 x) (+ x 1))
(define (abs n) "absolute value of number" (if (>= n 0) n (- n)))
(define (exact->inexact n) "make inexact number from exact" (* n 1.0))
(define (integer->float n) "make float from integer" (* n 1.0))
(define (<> n1 n2) "not equal" (not (= n1 n2)))
(define (math:divmod n d) "divmod operation" (list (/ n d) (mod n d)))
(define (>> n d) "right shift" (arithmetic-shift n (- d)))
(define (<< n d) "left shift" (arithmetic-shift n d))

(define (math:list-sum x) "calculate the sum of all elements in list"
  (reduce (lambda (acc x) (+ acc x)) 0 x))

(define (math:list-sum x) "calculate the sum of all elements in list"
  (reduce (lambda (acc x) (+ acc x)) 0 x))

(define (succ x) "next integer number" (+ (floor x) 1))
(define (pred x) "previous integer number" (- (floor x) 1))

(define (safe-div x y) "performs division; in case of division by zero it returns inf/-inf"
  (if (= y 0)
        (if (> x 0) (inf) (- (inf)))
        (/ x y)))

(define (math:gcd a b) "Greatest Common Divisor"
  (let ((aa (abs a))
    (bb (abs b)))
     (if (= bb 0)
          aa
          (math:gcd bb (remainder aa bb)))))

(define (math:lcm a b) "Least Common Multiple"
     (if (or (= a 0) (= b 0))
          0
          (abs (* (quotient a (math:gcd a b)) b))))

(define (math:fact n) "A tail-recursive version of factorial."
  (define (fact-aux n a)
    (if (< n 2) a (fact-aux (- n 1) (* n a))))
    (fact-aux n 1))

(define (math:fib n) "A version of fibonacci that runs in logarithmic time"
  (define (fib-aux a b p q count)
    (cond ((= count 0) b)
          ((math:even? count) (fib-aux a b (+ (pow p 2) (pow q 2)) (+ (* 2 p q) (pow q 2)) (/ count 2)))
          (else (fib-aux (+ (* b q) (* a q) (* a p))
                          (+ (* b p) (* a q))
                          p
                          q
                          (- count 1)))))
  (fib-aux 1 0 0 1 n))

(define (math:ncr n r) "Calculate nCr"
  (truncate (/ (math:fact n) (math:fact r) (math:fact (- n r)))))

(define (math:npr n r) "Calculate nPr"
  (truncate (/ (math:fact n) (math:fact (- n r)))))

(define (math:modpow base exp m) "calculates the exponential of a number modulo another number"
  (cond ((= exp 0) 1)
        ((math:even? exp) (remainder (pow (math:modpow base (/ exp 2) m) 2) m))
        (else (remainder (* base (math:modpow base (- exp 1) m)) m))))

(define (math:prob-prime? n times) "calculates whether number is probably a prime using fermat's theorem; not as good as miller-rabin"
  (define (fermat n)
    (define (prm a)
      (= (math:modpow a n n) a))
    (prm (randint 1 n)))
  (cond ((= times 0) #t)
        ((fermat n) (math:prob-prime? n (- times 1)))
        (else #f)))

; TODO: make tail recursive
(define (math:sigma term a n b op)
  "make a sigma sum (specified by op) produced by the values from a to b (as produced by n) applied to term;
   for a use case type (inspect math:integral-approx)"
  (if (> a b) 0 (op (term a) (math:sigma term (n a) n b op))))

(define (math:simpson f a b n)
  "calculates the approximate integral of function f with limits a and b
  where n is the approximation (the higher the better); uses simpson's rule"
  (let ((h (/. (- b a) n)))
    (define (y k)
      (f (+ a (* k h))))
    (define (term k)
      (* (cond ((math:odd? k) 4)
               ((or (= k 0) (= k n)) 1)
               (else 2))
         (y k)))
    (/. (* h (math:sigma term 0 add1 n +)) 3)))
