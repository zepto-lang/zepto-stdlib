(define (id obj) "returns an object"
  obj)

(define (inf? obj) "ist object infinite?"
  (if (and (number? obj) (inexact? obj))
    (= obj (* obj 10))
    #f))

(define (flip func) "flips two arguments for a function"
  (lambda (arg1 arg2)
    (func arg2 arg1)))

(define (curry f . y) "curry a function"
  (lambda z
    (apply f (++ y z))))

(define (compose f g . args) "compose two functions"
  (let ((constructed (lambda args (f (apply g args)))))
    (if (null? args)
      constructed
      (apply compose (cons constructed args)))))

(define (foldr func end l) "fold right"
  (if (list:null? l)
    end
    (func (list:car l) (foldr func end (list:cdr l)))))

(define (foldr1 func l) "fold right, assume first element is accumulator"
  (foldr func (car l) (cdr l)))

(define (foldl1 func l) "fold left, assume first element is accumulator"
  (foldl func (car l) (cdr l)))

(define (sum . l) "sum of values"
  (fold + 0 l))

(define (product . l) "product of values"
  (fold * 1 l))

(define (unzip1-with-cdr . lists)
  (unzip1-with-cdr-iterative lists '() '()))

(define (unzip1-with-cdr-iterative lists cars cdrs)
  (if (null? lists)
      (cons cars cdrs)
      (let ((car1 (caar lists))
        (cdr1 (cdar lists)))
    (unzip1-with-cdr-iterative 
     (cdr lists) 
     (append cars car1)
     (append cdrs cdr1)))))

(define (for-each proc . lists) "applies a function to a bunch of arguments"
  (if (null? lists)
      []
      (if (any? null? lists)
        []
        (let* ((unz (apply unzip1-with-cdr lists))
               (cars (car unz))
               (cdrs (cdr unz)))
          (cons
            (apply proc cars)
            (apply for-each (cons proc cdrs)))))))

(define (falsy? val) "is object falsy: empty if collection, 0 if number, #f if boolean"
  (cond
    ((boolean? val) (not val))
    ((hash-map? val) (list:null? (hash:keys val)))
    ((list? val) (list:null? val))
    ((vector? val) (eqv? {} val))
    ((byte-vector? val) (eqv? #() val))
    ((string? val) (eqv? "" val))
    ((number? val) (eqv? 0 val))
    (else #t)))

(define (truthy? val) "is object truthy: not empty if collection, !0 if number #t if boolean"
  (not (falsy? val)))

(define (constantly x) "takes any number of arguments and returns the first argument"
  (lambda args x))

(define (juxt . fs)
  "takes a set of functions and returns a function that is the juxtaposition
of those functions. The returned function takes a variable number of args, and
returns a vector containing the result of applying each given function to the
args (left-to-right)."
  (lambda args (map ($ (apply % args)) fs)))

(define (memoize f)
  "returns a memoized version of a referentially function. The
memoized version of the function keeps a cache of the mapping from arguments
to results and, when calls with the same arguments are repeated often, has
higher performance at the expense of higher memory use.
Caveat: he arguments must be simple values."
  (let ((cache #{}))
    (lambda args
      (let ((sargs (make-simple-list args)))
        (if (in? cache sargs)
          (cache sargs)
          (let ((res (apply f args)))
            (begin
              (hash:set! cache sargs res)
              res)))))))

(define (partition n c)
  "returns a list of lists of n items each."
  (define (internal acc tmp src)
    (cond
      ((null? src) acc)
      ((eq? (length tmp) n) (internal (+= acc tmp) (list (car src)) (cdr src)))
      (else (internal acc (++ tmp (car src)) (cdr src)))))
  (internal [] [] c))

(define (partition-all n c)
  "returns a list of lists of <par>n</par> items each, does not throw away the rest.

   params:
    - n: the size of the slices
    - c: the source collection (can be any collection type)
   complexity: O(n)
   returns: a list of lists"
  (define (internal acc tmp src)
    (cond
      ((null? src) (+= acc tmp))
      ((eq? (length tmp) n) (internal (+= acc tmp) (list (car src)) (cdr src)))
      (else (internal acc (++ tmp (car src)) (cdr src)))))
  (internal [] [] c))

(define (callable? obj)
  "check whether <par>obj</par> is callable.

   params:
    - obj: the object to check
   complexity: O(1)
   returns: a boolean"
  (or (function? obj) (primitive? obj)))

(define (ignoring pred f)
  "takes a predicate and a function and returns a function
   that filters out any argument to f that matches pred before
   applying them.

   params:
    - pred: the predicate
    - f: the function
   complexity: O(1)
   returns: a new function as described above"
  (lambda args
    (apply f (filter ($ (not (pred %))) args))))

(define (ignoring-nils f)
  "a specialized version of <par>ignoring</par> that ignores nil values.

   params:
     - f: the function
   complexity: O(1)
   returns: a new function as described in the documentation of <par>ignoring</par>"
  (ignoring nil? f))

(define (rate-limited f period)
  "creates a version of the function <par>f</par> which 'refuses' to be called too
   frequently. If it has successfully been called in the last <par>period</par>
   milliseconds, calls to it will return nil; if no calls have succeeded in that
   period, it will be called with the args provided.

   params:
     - f: the function
     - period: the number of milliseconds
   complexity: O(1)
   returns: a new function as described above"
  (let ((last-call 0))
    (lambda args
      (let* ((time (unix-timestamp))
             (cur (/ (+ (* (car time) 1000000000) (cadr time)) 1000000)))
        (if (< (+ period last-call) cur)
          (begin
            (set! last-call cur)
            (apply f args)))))))

(define (unfold next seed)
  "Traditionally unfold is the 'opposite of reduce': it turns a single
  seed value into a sequence of output values.

  <par>next</par> is a function that operates on a <par>seed</par>: it should
  return a pair, [value new-seed]; the value half of the pair is
  inserted into the resulting list, while the new seed is used to
  continue unfolding. Notably, the value is never passed as an
  argument to <par>next</par>. If <zepto>nil</zepto> is returned instead of a pair,
  the resulting sequence will terminate.

  Example:
  <zepto>
  (define (fibs-to n)
    (unfold (lambda (a b)
              (if (> b n)
                (nil)
                (list a (list b (+ a b)))))
             [0 1]))
  </zepto>

  params:
    - next: the function that produces values
    - seed: the original seeding value
  complexity: O(n*k) where k is the complexity of <par>next</par>
  returns: a list of the values produced by <par>next</par>"
  (let loop ((acc [])
             (nval (apply next seed)))
    (if (nil? nval)
      acc
      (loop (++ acc (car nval)) (apply next (cadr nval))))))

