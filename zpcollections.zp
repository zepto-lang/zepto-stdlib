(defprotocol left-collec pop-left append-left)
(defimpl left-collec vector?
         ((pop-left vector:head)
          (append-left (lambda (v el) (++ (vector el) v)))))
(defimpl left-collec byte-vector?
         ((pop-left byte-vector:head)
          (append-left (lambda (b el) (++ (byte-vector el) b)))))
(defimpl left-collec string?
         ((pop-left string:head)
          (append-left (lambda (s el) (++ (string el) v)))))
(defimpl left-collec list?
         ((pop-left car)
          (append-left list:append)))

(defprotocol right-collec pop-right)
(defimpl right-collec vector? ((pop-right vector:last)))
(defimpl right-collec byte-vector? ((pop-right byte-vector:last)))
(defimpl right-collec string? ((pop-right string:last)))

(defprotocol extensible-collec append extend)
(defimpl extensible-collec vector? ((append ++) (extend +=)))
(defimpl extensible-collec byte-vector? ((append ++) (extend +=)))
(defimpl extensible-collec string? ((append ++) (extend +=)))
(defimpl extensible-collec list? ((append ++) (extend +=)))

(define (collec:get-from-skeleton f)
  "a skeleton to nicely integrate your collection into the get-from world;
   expects a function that takes the collection, an element to get and a default return element"
  (lambda (collec elems . dflt)
    (let* ((dflt (if (null? dflt) (nil) (car dflt)))
           (elems (if (not (list? elems)) (list elems) elems)))
      (if (null? elems)
        collec
        (let ((ret (f collec (car elems) dflt)))
          (if (collec? ret)
            (get-from ret (cdr elems) dflt)
            (if (null? (cdr elems)) ret dflt)))))))

(defprotocol collec length in? get-from)
(defimpl collec vector?
         ((length vector:length)
          (in? vector:in?)
          (get-from (collec:get-from-skeleton (lambda (v i dflt) (if (> (length v) i) (v i) dflt))))))
(defimpl collec byte-vector?
         ((length byte-vector:length)
          (in? byte-vector:in?)
          (get-from (collec:get-from-skeleton (lambda (b i dflt) (if (> (length b) i) (b i) dflt))))))
(defimpl collec list?
         ((length list:length)
          (in? list:in?)
          (get-from (collec:get-from-skeleton (lambda (l i dflt)
                                                (if (> (length l) i) (list:ref l i) dflt))))))
(defimpl collec hash-map?
         ((length (lambda (x) (list:length (hash:keys x))))
          (in? hash:contains?)
          (get-from (collec:get-from-skeleton (lambda (h el dflt) (if (in? h el) (h el) dflt))))))
(defimpl collec string?
         ((length string:length)
          (in? string:in?) 
          (get-from (collec:get-from-skeleton (lambda (s i dflt)
                                                (if (> (length s) i) (string:ref s i) dflt))))))

(defprotocol summable gsum)
(defimpl summable vector? ((gsum (lambda (x) (math:list-sum (vector->list x))))))
(defimpl summable vector? ((gsum (lambda (x) (math:list-sum (byte-vector->list x))))))
(defimpl summable vector? ((gsum math:list-sum)))

(defprotocol indexable index-of)
(defimpl indexable vector? ((index-of vector:index)))
(defimpl indexable byte-vector? ((index-of byte-vector:index)))
(defimpl indexable list? ((index-of list:index)))
(defimpl indexable string? ((index-of string:find)))
