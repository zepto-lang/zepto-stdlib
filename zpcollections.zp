(defprotocol left-collec (pop-left 1) (append-left 2))
(defimpl left-collec vector?
         ((pop-left vector:head)
          (append-left (lambda (v el) (++ (vector el) v)))))
(defimpl left-collec byte-vector?
         ((pop-left byte-vector:head)
          (append-left (lambda (b el) (++ (byte-vector el) b)))))
(defimpl left-collec string?
         ((pop-left string:head)
          (append-left (lambda (s el) (++ (string el) v)))))
(defimpl left-collec list?
         ((pop-left list:car)
          (append-left list:append)))

(defprotocol right-collec (pop-right 1))
(defimpl right-collec vector? ((pop-right vector:last)))
(defimpl right-collec byte-vector? ((pop-right byte-vector:last)))
(defimpl right-collec string? ((pop-right string:last)))

(defprotocol extensible-collec (append :overloaded) (extend :overloaded))
(defimpl extensible-collec vector? ((append +=) (extend ++)))
(defimpl extensible-collec byte-vector? ((append +=) (extend ++)))
(defimpl extensible-collec string? ((append +=) (extend ++)))
(defimpl extensible-collec list? ((append +=) (extend ++)))

(define (collec:get-from-skeleton f)
  "a skeleton to nicely integrate your collection into the get-from world;
   expects a function that takes the collection, an element to get and a default return element"
  (lambda (collec elems . dflt)
    (let* ((dflt (if (null? dflt) (nil) (car dflt)))
           (elems (if (not (list? elems)) (list elems) elems)))
      (if (null? elems)
        collec
        (let ((ret (f collec (car elems) dflt)))
          (if (collec? ret)
            (get-from ret (cdr elems) dflt)
            (if (null? (cdr elems)) ret dflt)))))))

(defprotocol traversable-collec (car 1) (cdr 1))
(defimpl traversable-collec list? ((car list:car) (cdr list:cdr)))
(defimpl traversable-collec vector? ((car vector:head) (cdr vector:tail)))
(defimpl traversable-collec byte-vector? ((car byte-vector:head) (cdr byte-vector:tail)))
(defimpl traversable-collec string? ((car string:head) (cdr string:tail)))

(define head car)
(define tail cdr)
(define (genmap func l) 
  (define (internal l acc)
    (if (= (length l) 0)
      acc
      (internal (cdr l) (++ acc (func (car l))))))
  (internal l []))

(define (take-nth n l)
  (define (internal i acc l)
    (if (null? l)
      acc
      (let ((acc (if (= (mod i n) 0) (++ acc (car l)) acc)))
        (internal (add1 i) acc (cdr l)))))
  (internal 0 [] l))

(defprotocol collec (length 1) (in? 2) (get-from :overloaded))
(defimpl collec vector?
         ((length vector:length)
          (in? vector:in?)
          (get-from (collec:get-from-skeleton (lambda (v i dflt) (if (> (length v) i) (v i) dflt))))))
(defimpl collec byte-vector?
         ((length byte-vector:length)
          (in? byte-vector:in?)
          (get-from (collec:get-from-skeleton (lambda (b i dflt) (if (> (length b) i) (b i) dflt))))))
(defimpl collec list?
         ((length list:length)
          (in? list:in?)
          (get-from (collec:get-from-skeleton (lambda (l i dflt)
                                                (if (> (length l) i) (list:ref l i) dflt))))))
(defimpl collec hash-map?
         ((length (lambda (x) (list:length (hash:keys x))))
          (in? hash:contains?)
          (get-from (collec:get-from-skeleton (lambda (h el dflt) (if (in? h el) (h el) dflt))))))
(defimpl collec string?
         ((length string:length)
          (in? string:in?) 
          (get-from (collec:get-from-skeleton (lambda (s i dflt)
                                                (if (> (length s) i) (string:ref s i) dflt))))))

(defprotocol summable (gsum 1))
(defimpl summable vector? ((gsum (lambda (x) (math:list-sum (vector->list x))))))
(defimpl summable vector? ((gsum (lambda (x) (math:list-sum (byte-vector->list x))))))
(defimpl summable vector? ((gsum math:list-sum)))

(defprotocol indexable (index-of 2))
(defimpl indexable vector? ((index-of vector:index)))
(defimpl indexable byte-vector? ((index-of byte-vector:index)))
(defimpl indexable list? ((index-of list:index)))
(defimpl indexable string? ((index-of string:find)))
