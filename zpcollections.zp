(defprotocol left-collec (pop-left 1) (append-left 2))
(defimpl left-collec vector?
         ((pop-left vector:head)
          (append-left (lambda (v el) (++ (vector el) v)))))
(defimpl left-collec byte-vector?
         ((pop-left byte-vector:head)
          (append-left (lambda (b el) (++ (byte-vector el) b)))))
(defimpl left-collec string?
         ((pop-left string:head)
          (append-left (lambda (s el) (++ (string el) v)))))
(defimpl left-collec list?
         ((pop-left list:car)
          (append-left list:append)))

(defprotocol right-collec (pop-right 1))
(defimpl right-collec vector? ((pop-right vector:last)))
(defimpl right-collec byte-vector? ((pop-right byte-vector:last)))
(defimpl right-collec string? ((pop-right string:last)))

(defprotocol extensible-collec (append :overloaded) (extend :overloaded))
(defimpl extensible-collec vector? ((append +=) (extend ++)))
(defimpl extensible-collec byte-vector? ((append +=) (extend ++)))
(defimpl extensible-collec string? ((append +=) (extend ++)))
(defimpl extensible-collec list? ((append +=) (extend ++)))

(define (collec-val:found? val)
  (cadr val))
(define (collec-val:val val)
  (car val))
(define (collec-val:found val)
  (list val #t))
(define (collec-val:not-found)
  (list (nil) #f))

(define (collec:get-from-skeleton f)
  "a skeleton to nicely integrate your collection into the get-from world;
   expects a function that takes the collection, an element to get and a default return element"
  (lambda (collec elems . dflt)
    (let* ((dflt (if (null? dflt) (nil) (car dflt)))
           (elems (if (list? elems) elems (list elems))))
      (if (null? elems)
        collec
        (let* ((ret (f collec (car elems)))
               (stop (not (collec-val:found? ret)))
               (ret (collec-val:val ret)))
          (cond
            (stop dflt)
            ((collec? ret) (get-from ret (cdr elems) dflt))
            (else (if (null? (cdr elems)) ret dflt))))))))

(define (collec:update-in-skeleton f)
  (lambda (collec elems uf)
    (let ((elems (if (list? elems) elems (list elems))))
      (cond
        ((null? elems) collec)
        ((null? (cdr elems))
          (if (or (not (callable? uf)) (in? collec (car elems)))
            (f collec (car elems) (if (callable? uf) uf (lambda args uf)))
            collec))
        (else
          (let ((ret (get-from collec (car elems))))
            (if (updatable-collec? ret)
              (f collec (car elems) (lambda args (update-in ret (cdr elems) uf)))
              collec)))))))

(define (collec:delete-from-skeleton f)
  (lambda (collec elems)
    (let ((elems (if (list? elems) elems (list elems))))
      (cond
        ((null? elems) collec)
        ((null? (cdr elems))
          (if (in? collec (car elems))
            (f collec (car elems)))
            collec)
        (else
          (let ((ret (get-from collec (car elems))))
            (if (updatable-collec? ret)
              (update-in collec (car elems) (lambda args (delete-from ret (cdr elems))))
              collec)))))))

(defprotocol traversable-collec (car 1) (cdr 1) (null? 1))
(defimpl traversable-collec list? ((car list:car) (cdr list:cdr) (null? list:null?)))
(defimpl traversable-collec vector? ((car vector:head) (cdr vector:tail) (null? vector:empty?)))
(defimpl traversable-collec byte-vector? ((car byte-vector:head) (cdr byte-vector:tail) (null? byte-vector:empty?)))
(defimpl traversable-collec string? ((car string:head) (cdr string:tail) (null? string:empty?)))

(define head car)
(define tail cdr)

(define (take-nth n l)
  (define (internal i acc l)
    (if (null? l)
      acc
      (let ((acc (if (= (mod i n) 0) (++ acc (car l)) acc)))
        (internal (add1 i) acc (cdr l)))))
  (internal 0 [] l))

(defprotocol collec (length 1) (in? 2) (get-from :overloaded))
(defimpl collec vector?
         ((length vector:length)
          (in? vector:in?)
          (get-from (collec:get-from-skeleton
                      (lambda (v i)
                        (if (> (length v) i) (collec-val:found (v i)) (collec-val:not-found)))))))
(defimpl collec byte-vector?
         ((length byte-vector:length)
          (in? byte-vector:in?)
          (get-from (collec:get-from-skeleton
                      (lambda (v i)
                        (if (> (length v) i) (collec-val:found (v i)) (collec-val:not-found)))))))
(defimpl collec list?
         ((length list:length)
          (in? list:in?)
          (get-from (collec:get-from-skeleton
                      (lambda (l i)
                        (if (> (length l) i)
                          (collec-val:found (list:ref l i))
                          (collec-val:not-found)))))))
(defimpl collec hash-map?
         ((length (lambda (x) (list:length (hash:keys x))))
          (in? hash:contains?)
          (get-from (collec:get-from-skeleton
                      (lambda (h el)
                        (if (in? h el) (collec-val:found (h el)) (collec-val:not-found)))))))
(defimpl collec string?
         ((length string:length)
          (in? string:in?) 
          (get-from (collec:get-from-skeleton
                      (lambda (s i)
                        (if (> (length s) i)
                          (collec-val:found (string:ref s i))
                          (collec-val:not-found)))))))

(defprotocol updatable-collec (update-in 3) (delete-from 2))
(defimpl updatable-collec hash-map?
         ((update-in (collec:update-in-skeleton hash:update))
          (delete-from (collec:delete-from-skeleton hash:remove))))

(defprotocol summable (gsum 1))
(defimpl summable vector? ((gsum (lambda (x) (math:list-sum (vector->list x))))))
(defimpl summable byte-vector? ((gsum (lambda (x) (math:list-sum (byte-vector->list x))))))
(defimpl summable list? ((gsum math:list-sum)))

(defprotocol indexable (index-of 2))
(defimpl indexable vector? ((index-of vector:index)))
(defimpl indexable byte-vector? ((index-of byte-vector:index)))
(defimpl indexable list? ((index-of list:index)))
(defimpl indexable string? ((index-of string:find)))

(define (take n c)
  "returns a list of the first n items in the collection c,
or all items if there are fewer than n."
  (define (internal i acc c)
    (if (or (= i n) (null? c))
      acc
      (internal (add1 i) (++ acc (car c)) (cdr c))))
  (internal 0 [] c))

(define (drop n c)
  "elides the first n values from the collection c."
  (define (internal i c)
    (if (null? c)
      []
      (if (= i n)
        c
        (internal (add1 i) (cdr c)))))
  (internal 0 c))

(define (take-while pred c)
  "returns a list of all the first items of the collection c
while pred is true."
  (define (internal acc c)
    (if (null? c)
      acc
      (let ((f (car c)))
        (if (pred f)
          (internal (++ acc f) (cdr c))
          acc))))
  (internal [] c))

(define (drop-while pred c)
  "elides values from the collection c as long as pred is true."
  (define (internal c)
    (if (and (not (null? c)) (pred (car c)))
      (internal (cdr c))
      c))
  (internal c))

(define (take-nth n c)
 "returns a list of every nth item in the collection c."
  (define (internal i acc c)
    (if (null? c)
      acc
      (internal (add1 i) (++ acc (if (eq? 0 (mod i n)) (car c) [])) (cdr c))))
  (internal 0 [] c))

(define (split-at n c) "returns a list of [(take n c) (drop n c)]"
  (list (take n c) (drop n c)))

(define (split-with pred c) "returns a list of [(take-while pred c) (drop-while pred c)]"
  (list (take-while pred c) (drop-while pred c)))
