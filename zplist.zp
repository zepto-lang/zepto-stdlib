(define (list . objs) "creates a list from objects"
  objs)

(define (list:matches? pred? l) "check whether there is an element in l that matches the predicate pred?"
  (cond ((null? l) #f)
  ((pred? (car l)) #t)
  (else (list:matches? pred? (cdr l)))))

(define (list:index l el) "get index of el in l; otherwise get -1"
  (if (null? l)
    -1
    (if (eq? (car l) el)
      0
      (let ((res (list:index (cdr l) el)))
        (if (= res -1) 
        -1
        (+ 1 res))))))

(define (list:after l el) "returns sublist of l after first occurrence of element el"
  (indexed-tail l (+ (list:index l el) 1)))

(define (list:count l el) "returns number of occurences of el in l"
  (reduce (lambda (acc now) (if (eqv? now el) (+ acc 1) acc)) 0 l))

(define (max first . l) "maximum of values"
  (fold (lambda (old new) (if (> old new) old new)) first l))

(define (min first . l) "minimum of values"
  (fold (lambda (old new) (if (< old new) old new)) first l))

(define (list:min l) "minimum in list"
  (fold (lambda (old new) (if (< old new) old new)) (car l) (cdr l)))

(define (list:max l) "maximum in list"
  (fold (lambda (old new) (if (> old new) old new)) (car l) (cdr l)))

(define (list:in? l el) "returns boolean signifying whether element is in list"
  (<= 0 (list:index l el)))

(define (indexed-tail l k) "get tail of a list starting at index"
    (if (zero? k)
      l
      (indexed-tail (cdr l) (- k 1))))

(define list:drop (flip indexed-tail))

(define (list:ref l . k) "get reference to list element at certain point"
    (if (= 1 (length k))
        (car (indexed-tail l (car k)))
        (reverse (indexed-tail (reverse (indexed-tail l (car k))) (- (length l) (cadr k))))))

(define (list:remove-n l n) "deletes nth element from list"
  (if (= n 0) 
      (cdr l)
      (++ (list (car l)) (list:remove-n (cdr l) (- n 1)))))

(define (list:tail l) "get tail of a list"
  (cdr l))

(define (list:length l) "length of list"
  (fold (lambda (x y) (+ x 1)) 0 l))

(define (reverse l) "reverse list"
  (fold (flip cons) '() l))

(define (my-mem-helper obj lst cmp-proc)
    (cond
        ((null? lst) #f)
        ((cmp-proc obj (car lst)) lst)
        (else (my-mem-helper obj (cdr lst) cmp-proc))))

(define (memq obj lst) (my-mem-helper obj lst eq?))

(define (memv obj lst) (my-mem-helper obj lst eqv?))

(define (member obj lst) (my-mem-helper obj lst equal?))

(define (mem-helper pred op) (lambda (acc next) (if (and (not acc) (pred (op next))) next acc)))

(define (assq obj alist) (fold (mem-helper (curry eq? obj) car) #f alist))

(define (assv obj alist) (fold (mem-helper (curry eqv? obj) car) #f alist))

(define (assoc obj alist) (fold (mem-helper (curry equal? obj) car) #f alist))

(define (map func l) "map function to list"
  (foldr (lambda (x y) (cons (func x) y)) [] l))

(define (indexed-map func l) "indexed map function to list"
  (cdr (foldr (lambda (x y) 
    (let ((i (car y)))
      (cons (+ i 1) (cons (func x i) (cdr y)))))
    [0] l)))

(define (zip a b) "zips two lists together"
  (if (or (null? a) (null? b)) [] (++ (list (head a) (head b)) (zip (tail a) (tail b)))))

(define foreach map)

(define (filter pred l) "filter list with predicate"
  (foldr (lambda (x y) (if (pred x) (cons x y) y)) [] l))

(define (remp pred l) "filter list with predicate (inverse to filter)"
  (foldr (lambda (x y) (if (not (pred x)) (cons x y) y)) [] l))

(define (any? pred lst) "does anything in the list satisfy the predicate?"
  (let any* ((l (map pred lst)))
    (cond
      ((null? l) #f)
      ((car l) #t)
      (else
        (any* (cdr l))))))

(define (every? pred lst) "do all values in the list satisfy the predicate?"
  (let every* ((l (map pred lst)))
    (cond
      ((null? l) #t)
      ((car l)
       (every* (cdr l)))
      (else
        #f))))

(define all? every?)

(define (range x . l)
  (begin
    (define build (lambda (c) (if (< c x) (cons c (build (+ c 1))) [])))
    (define from-to (lambda (x y) (if (>= x y) [] (cons x (from-to (+ x 1) y)))))
    (define step (lambda (x y z) (if (>= x y) [] (cons x (step (+ x z) y z)))))
    (cond ((null? l) (build 0))
          ((= 1 (length l)) (from-to x (car l)))
          ((= 2 (length l)) (step x (car l) (cadr l)))
          (else (error "usage: range [from] to [step]")))))

(define iota range)

(define (replicate n el) "build a list of length n with only el in it"
  (if (< n 1)
    ""
    (++ el (replicate (- n 1) el))))
