(define (->string el . with-quotes) "converts almost any element to a string"
  (let ((to-str (if (> (length with-quotes) 0)
                  (if (truthy? (car with-quotes))
                    (lambda (str) (++ "\"" el "\""))
                    id)
                  id)))
    (cond
      ((nil? el) "<nil>")
      ((hash-map? el)
        (let ((s (hash:keys-reduce (lambda (acc x) (++ acc (->string x #t) ": " (->string (el x) #t) ", ")) "{" el)))
          (++ (substring s 0 (- (length s) 2)) "}")))
      ((string? el) (to-str el))
      ((number? el) (number->string el))
      ((list? el)
        (if (null? el)
          "[]"
          (++ "[" (reduce (lambda (acc x) (++ acc ", " (->string x #t))) (->string (head el) #t) (tail el)) "]")))
      ((vector? el)
        (if (vector:empty? el)
          "{}"
          (++ "{"
              (vector:reduce (lambda (acc x) (++ acc ", " (->string x #t)))
                (->string (vector:head el) #t) (vector:tail el))
              "}")))
      ((simple-list? el)
        (let ((el (from-simple-list el)))
          (if (null? el)
            "simple[]"
            (++ "simple["
                (reduce (lambda (acc x) (++ acc ", " (->string x #t))) (->string (head el) #t) (tail el))
                "]"))))
      ((byte-vector? el)
        (if (byte-vector:empty? el)
          "byte{}"
          (++ "byte{"
              (byte-vector:reduce
                (lambda (acc x) (++ acc ", " (->string x #t)))
                (->string (byte-vector:head el) #t)
                (byte-vector:tail el))
              "}")))
      ((or (atom? el) (symbol? el)) (symbol->string el))
      ((port? el) "<port>")
      ((char? el) (string el))
      ((boolean? el) (if el "true" "false"))
      (else "???"))))

(define (pprint obj . args)
  "pretty print a data object obj; the output is configurable via a hashmap args;
   parameter :indent (width as integer) :max-width (as integer) and :data (currently unused)
   are supported"
  (let* ((dflt #{:indent 2 :max-width 80 :data #t})
         (args (if (> (length args) 0) (make-hash dflt (car args)) dflt)))
  (define (internal-code obj i w)
    (define (soft-break i w)
      (if (>= w (args :max-width))
        (begin
          (display (++ "\n" (string:replicate i #\space)))
          (internal-code (string:tail obj) i 0))
        (internal-code (string:tail obj) i w)))
    (if (string:empty? obj)
      (write "")
      (let ((w (add1 w)))
        (begin
          (display (string (string:head obj)))
          (case (string:head obj)
            ((#\space)
              (soft-break i w))
            ((#\tab)
              (soft-break i w))
            ((#\()
              (soft-break (+ i (args :indent)) w))
            ((#\))
              (soft-break (- i (args :indent)) w))
            (else (internal-code (string:tail obj) i w)))))))
  (define (internal obj i w)
    (define (soft-break i w)
      (if (>= w (args :max-width))
        (begin
          (display (++ "\n" (string:replicate i #\space)))
          (internal (string:tail obj) i 0))
        (internal (string:tail obj) i w)))
    (if (string:empty? obj)
      (write "")
      (let ((w (add1 w)))
        (begin
          (display (string (string:head obj)))
          (case (string:head obj)
            ((#\space)
              (soft-break i w))
            ((#\tab)
              (soft-break i w))
            ((#\{)
              (soft-break w w))
            ((#\[)
              (soft-break w w))
            ((#\()
              (soft-break (+ w (args :indent)) w))
            ((#\})
              (soft-break w w))
            ((#\])
              (soft-break w w))
            ((#\))
              (soft-break (- w (args :indent)) w))
            (else (internal (string:tail obj) i w)))))))
  (if (args :data)
    (internal (->string obj) 0 0)
    (internal-code (->string obj) 0 0))))


(define (->bytes x) "generates byte-vector from data structure"
  (cond
    ((nil? x) b{0})
    ((byte-vector? x) (byte-vector->list x))
    ((number? x) (number->bytes x))
    ((string? x) (string->byte-vector x))
    ((hash-map? x)
      (hash:kv-reduce (lambda (acc kv) (++ acc (->bytes (car kv) (->bytes (cadr kv))))) b{} x))
    ((vector? x) (vector:reduce (lambda (acc x) (++ acc (->bytes x))) b{} x))
    ((list? x) (reduce (lambda (acc x) (++ acc (->bytes x))) b{} x))
    ((char? x) (->bytes (string x)))
    ((port? x) b{0})
    ((boolean? x) (if x b{1} b{0}))
    ((or (atom? x) (symbol? x)) (->bytes (symbol->string x)))
    (else b{0})))
