(define *protocols* #{})
(define *impls* #{})

(define-syntax defprotocol
  (syntax-rules ()
    ((_ name functions ...)
      (let ((env (current-env))
            (str (symbol->string 'name)))
        (begin
          (eval `(define (,(string->symbol (++ str "?")) arg)
                   (let* ((impls (*impls* ,str))
                          (funs (hash:kv-filter
                                  (lambda (kv) (eval (list (string->symbol (car kv)) 'arg)))
                                  (if (truthy? impls) impls (make-hash)))))
                    (not (null? funs))))
                env)
          (map
            (lambda (x)
              (define strx (symbol->string x))
              (eval `(define ,x (lambda args
                        (let ((impls (*impls* ,str))
                              (arg (car args)))
                          (if (nil? impls)
                            (error "No implementation specified for protocol" ,str)
                            (let ((funs (hash:kv-filter
                                          (lambda (kv) (eval (list (string->symbol (car kv)) 'arg)))
                                          impls)))
                              (if (null? funs)
                                (error "No implementation of protocol" (typeof arg)
                                       "found that matches" ,str)
                                (apply ((cadar funs) ,strx) args))))))) env))
            'functions)
          (hash:set! *protocols* (symbol->string 'name) 'functions))))))

(define-syntax defimpl
  (syntax-rules ()
    ((_ name pred funcs)
      (let ((proto (*protocols* (symbol->string 'name)))
            (given (map car 'funcs))
            (wrong-forms (filter (lambda (x) (/= 2 (list:length x))) 'funcs))
            (nfuncs (map (lambda (x) (list (symbol->string (car x)) (eval (cadr x)))) 'funcs)))
        (if (null? wrong-forms)
          (if (nil? proto)
            (error "protocol" 'name "not defined.")
            (if (eq? proto given)
              (hash:update! *impls* (symbol->string 'name)
                         (lambda (x) 
                            (let ((x (if (truthy? x) x #{})))
                              (hash:set! x (symbol->string 'pred) (make-hash nfuncs)))))
              (error "protocol" 'name "expects" proto "to be defined, was given" given)))
          (error "wrong forms" wrong-forms "; expect forms to be of the form (name implementation)"))))))

(defprotocol stringify ->string)

(defimpl stringify nil? ((->string (lambda (x) "<nil>"))))
(defimpl stringify hash-map?
         ((->string
           (lambda (el)
            (let ((s (hash:keys-reduce (lambda (acc x)
                                            (++ acc (->string x) ": " (->string (el x)) ", "))
                                       "{"
                                       el)))
              (++ (substring s 0 (- (string:length s) 2)) "}"))))))
(defimpl stringify string? ((->string id)))
(defimpl stringify number? ((->string number->string)))
(defimpl stringify list?
         ((->string
            (lambda (el)
              (if (null? el)
                "[]"
                (++ "["
                     (reduce (lambda (acc x) (++ acc ", " (->string x)))
                             (->string (head el))
                             (tail el))
                     "]"))))))
(defimpl stringify vector?
         ((->string
            (lambda (el)
              (if (vector:empty? el)
                "{}"
                (++ "{"
                    (vector:reduce (lambda (acc x) (++ acc ", " (->string x)))
                                   (->string (vector:head el))
                                   (vector:tail el))
                    "}"))))))
(defimpl stringify simple-list?
         ((->string
            (lambda (el)
              (let ((el (from-simple-list el)))
                (if (null? el)
                  "simple[]"
                  (++ "simple["
                      (reduce (lambda (acc x) (++ acc ", " (->string x)))
                              (->string (head el))
                              (tail el))
                      "]")))))))
(defimpl stringify byte-vector?
         ((->string
            (lambda (el)
              (if (byte-vector:empty? el)
                "byte{}"
                (++ "byte{"
                    (byte-vector:reduce (lambda (acc x) (++ acc ", " (->string x)))
                                        (->string (byte-vector:head el))
                                        (byte-vector:tail el))
                    "}"))))))
(defimpl stringify atom? ((->string symbol->string)))
(defimpl stringify symbol? ((->string symbol->string)))
(defimpl stringify port? ((->string (lambda (x) "<port"))))
(defimpl stringify char? ((->string string)))
(defimpl stringify boolean? ((->string (lambda (el) (if el "true" "false")))))

(define (pprint obj . args)
  "pretty print a data object obj; the output is configurable via a hashmap args;
   parameter :indent (width as integer) :max-width (as integer) and :data (currently unused)
   are supported"
  (let* ((dflt #{:indent 2 :max-width 80 :data #t})
         (args (if (> (list:length args) 0) (make-hash dflt (car args)) dflt)))
  (define (internal-code obj i w)
    (define (soft-break i w)
      (if (>= w (args :max-width))
        (begin
          (display (++ "\n" (string:replicate i #\space)))
          (internal-code (string:tail obj) i 0))
        (internal-code (string:tail obj) i w)))
    (if (string:empty? obj)
      (write "")
      (let ((w (add1 w)))
        (begin
          (display (string (string:head obj)))
          (case (string:head obj)
            ((#\space)
              (soft-break i w))
            ((#\tab)
              (soft-break i w))
            ((#\()
              (soft-break (+ i (args :indent)) w))
            ((#\))
              (soft-break (- i (args :indent)) w))
            (else (internal-code (string:tail obj) i w)))))))
  (define (internal obj i w)
    (define (soft-break i w)
      (if (>= w (args :max-width))
        (begin
          (display (++ "\n" (string:replicate i #\space)))
          (internal (string:tail obj) i 0))
        (internal (string:tail obj) i w)))
    (if (string:empty? obj)
      (write "")
      (let ((w (add1 w)))
        (begin
          (display (string (string:head obj)))
          (case (string:head obj)
            ((#\space)
              (soft-break i w))
            ((#\tab)
              (soft-break i w))
            ((#\{)
              (soft-break w w))
            ((#\[)
              (soft-break w w))
            ((#\()
              (soft-break (+ w (args :indent)) w))
            ((#\})
              (soft-break w w))
            ((#\])
              (soft-break w w))
            ((#\))
              (soft-break (- w (args :indent)) w))
            (else (internal (string:tail obj) i w)))))))
  (if (args :data)
    (internal (->string obj) 0 0)
    (internal-code (->string obj) 0 0))))

(defprotocol bytify ->bytes)
(defimpl bytify nil? ((->bytes (lambda (x) b{0}))))
(defimpl bytify byte-vector? ((->bytes id)))
(defimpl bytify number? ((->bytes number->bytes)))
(defimpl bytify string? ((->bytes string->byte-vector)))
(defimpl bytify hash-map? ((->bytes
         (lambda (x)
            (hash:kv-reduce (lambda (acc kv) (++ acc (->bytes (car kv)) (->bytes (cadr kv)))) b{} x)))))
(defimpl bytify list? ((->bytes (lambda (x) (reduce (lambda (acc x) (++ acc (->bytes x))) b{} x)))))
(defimpl bytify char? ((->bytes (lambda (x) (->bytes (string x))))))
(defimpl bytify port? ((->bytes (lambda (x) b{0}))))
(defimpl bytify boolean? ((->bytes (lambda (x) (if x b{1} b{0})))))
(defimpl bytify atom? ((->bytes (lambda (x) (->bytes (symbol->string x))))))
(defimpl bytify symbol? ((->bytes (lambda (x) (->bytes (symbol->string x))))))

(define-syntax ->symbol
  (syntax-rules ()
    ((->symbol xs ...)
      (string->symbol (reduce ++ "" (map ->string '(xs ...)))))))

