(define (sort:sorted? seq . ord) "is sequence sorted? Optionally takes an order function, default is <"
  (let ((ord (if (null? ord) < (list:ref ord 0))))
  (if (< (length seq) 2)
    #t
    (and (ord (car seq) (cadr seq)) (sort:sorted? (cdr seq) ord)))))

(define (sort:merge a b . ord) "merge two sorted lists; optionally takes an order function, default is <"
  (let ((ord (if (null? ord) < (list:ref ord 0))))
  (cond
    ((null? a) b)
    ((null? b) a)
    (else (let loop
               ((x (head a))
                (a (tail a))
                (y (head b))
                (b (tail b)))
        (if (ord y x)
          (if (null? b)
            (cons y (cons x a))
            (cons y (loop x a (car b) (cdr b))))
          (if (null? a)
            (cons x (cons y b))
            (cons x (loop (car a) (cdr a) y b)))))))))

(define (sort:quick-sort l . ord) "sort a list with quick sort scheme; optionally takes an order function, default is <"
  (let ((ord (if (null? ord) < (list:ref ord 0))))
  (if (< (length l) 2) 
    l
    (let loop ((left []) (right [])
               (h (car l)) (t (cdr l)))
      (if (null? t)
        (++ (++ (sort:quick-sort left ord) (list h)) (sort:quick-sort right ord))
        (if (ord (car t) h)
          (loop (++ left (list (car t))) right h (cdr t))
          (loop left (++ right (list (car t))) h (cdr t))))))))
